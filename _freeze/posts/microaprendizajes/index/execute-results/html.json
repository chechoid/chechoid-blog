{
  "hash": "e863f985bd1314b09c194fe993770721",
  "result": {
    "markdown": "---\ntitle: \"Microaprendizajes de un proyecto\"\ndate: \"22/05/2021\"\nauthor: \"Checho\"\ncategories: [ggplot2, tipito, tip, visualización, rmarkdown]\n---\n\n\n# Introducción\n\nEsta presentación se centra en algunos *microaprendizajes* de un proyecto de análisis de resultados de una encuesta de diversidad e inclusión.\n\nLo razón por la que lo llamo *\"microaprendizajes\"* es porque no tuve que aprender muchas cosas desde cero, pero si aprendí varios truquitos que me sirvieron mucho.\n\nVoy a usar una encuesta simulada para no violar la confidencialidad de los datos, pero va a ser algo análogo a lo que estuve usando en el proyecto.\n\nPara explotar al máximo esta sesión conviene saber un poco de hacer informes con RMarkdown. Si necesitás un tutorial sobre ese tema te comparto el [video que hicimos el año pasado](https://youtu.be/KT4UfTqAYoU).\n\n### ![](https://media.npr.org/assets/img/2023/05/26/honest-work-meme-cb0f0fb2227fb84b77b3c9a851ac09b095ab74d8-s1100-c50.jpg){width=\"395\"}\n\n### `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 496 512\" style=\"height:1em;width:0.97em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:steelblue;overflow:visible;position:relative;\"><path d=\"M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z\"/></svg>`{=html} [Repo](https://github.com/r4hr/r4hr_microaprendizajes)\n\nEste material se puede utilizar y compartir sin fines comerciales y citando la fuente.\n\n![Licencia](https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/Cc-by-nc_icon.svg/1200px-Cc-by-nc_icon.svg)\n\n# Aprendizajes\n\n## El *chunk* de 'setup'\n\nEl bloque de código de `setup` es muy útil para controlar cómo se van a comportar todos los bloques de código.\n\nMi archivo original tiene +150 bloques de código, imaginen si modificara uno por uno las características de cada bloque.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.retina = 3,\n                      out.width = \"80%\")\n```\n:::\n\n\n## Ordenar el código\n\nTener un orden en el código es muy importante para poder ir y venir rápido y encontrar rápidamente las cosas, modificar algo, y demás.\n\nDentro de los bloques de código también es importante poner títulos o marcadores que nos ayuden a encontrar rápido las cosas. El orden que definí fue:\n\n1.  Librerías.\n2.  Configuraciones generales\n3.  Carga de datos\n4.  Preprocesamiento y limpieza de datos\n5.  Funciones\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Librerías -----\nlibrary(tidyverse)\nlibrary(gt)\nlibrary(scales)\nlibrary(extrafont)\nlibrary(readxl)\n\n\n# Configuraciones generales ----------\n\n# Colores\nverde <- \"#01B3B6\"\nnegro <- \"#333132\"\ngris <- \"#AEB6BF\"\n\ncolor3 <- c(verde, gris, negro)\ncolor2 <- c(verde, negro)\n\n# Opciones de visualización --------\noptions(scipen = 999)   # Modifica la visualización de los ejes numérico a valores nominales\n\nloadfonts(quiet = TRUE) # Permite cargar en R otros tipos de fuentes.\n\n# Estilo limpio sin líneas de fondo\nestilo <- theme(panel.grid = element_blank(),\n                plot.background = element_rect(fill = \"#FBFCFC\"),\n                panel.background = element_blank(),\n                text = element_text(family = \"Ubuntu Mono\"))\n\n# Estilo limpio con líneas de referencia verticales en gris claro\nestilov <- theme(panel.grid = element_blank(),\n                 plot.background = element_rect(fill = \"#FBFCFC\"),\n                 panel.background = element_blank(),\n                 panel.grid.major.x = element_line(color = \"#ecf0f1\"),\n                 text = element_text(family = \"Ubuntu Mono\"))\n\n# Estilo limpio con líneas de referencia horizontales en gris claro\nestiloh <- theme(panel.grid = element_blank(),\n                 plot.background = element_rect(fill = \"#FBFCFC\"),\n                 panel.background = element_blank(),\n                 panel.grid.major.y = element_line(color = \"#ecf0f1\"),\n                 text = element_text(family = \"Ubuntu Mono\"))\n\n\n# Creo un objeto con un texto que se va a repetir mucho a lo largo del análisis\nfuente <- \"Club de R para RRHH\\nDatos Ficticios\"\n\n# Creo objetos para formatear las etiquetas numéricas de los ejes x e y\neje_x_per <- scale_x_continuous(labels = scales::percent_format(accuracy = 1))\n\neje_y_per <- scale_y_continuous(labels = scales::percent_format(accuracy = 1))\n\n# Carga de Datos -----\nencuesta <- read_excel(\"data/encuesta.xlsx\")\nplantel  <- read_excel(\"data/plantel.xlsx\")\n\n# Preparación de datos -----------\n\n# Pivotea el dataset a un formato largo\nenc <- encuesta %>% \n  pivot_longer(cols = c(7:11),\n               names_to = \"pregunta\", \n               values_to = \"valor\")\n\n# Cambia nombres y Organiza variables ordinales \n\nenc <- enc %>% \n  rename(id = \"ID\",\n         genero = `¿Cómo definirías tu identidad de género?`,\n         unidad = \"Unidad de Negocio\",\n         pais = \"País\",\n         sector = \"Sector\",\n         cargo = \"Tu cargo/nivel:\") %>% \n  mutate(cargo = factor(cargo,\n                        levels = c(\"Management\", \"Líder\", \"Contribuidor individual\")))\n\n# Crea categorías de resultados\n\nenc <- enc %>% \n  mutate(resultado = if_else(valor == \"Totalmente de acuerdo\", \"Positivo\", \n                             if_else(valor == \"De acuerdo\", \"Positivo\", \n                                     if_else(valor == \"Ni de acuerdo ni en desacuerdo\",\n                                             \"Neutral\", \"Negativo\"\n      )\n    )\n  ),\n         resultado = factor(resultado, \n                            levels = c(\"Positivo\", \"Neutral\", \"Negativo\")))\n```\n:::\n\n\n> Y comenten el código por amor a Jebús!\n\n![](files/comenten.png){width=\"300\"}\n\n## Poner el nombre a los bloques de código\n\nAlgo muy útil es ponerle nombre a los bloques de código. Por un lado porque es fácil para navegar entre bloques buscándolos en RStudio.\n\nPor ejemplo, probemos un gráfico simple:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(enc, aes(x = pais, fill = resultado)) +\n  geom_bar(position = \"fill\") +\n  scale_fill_manual(values = c(color3)) +\n  estiloh +\n  eje_y_per +\n  labs(title = \"Resultados por país\",\n       fill = \"Resultado\",\n       x = \"\", y = \"\",\n       caption = fuente)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/grafico1-1.png){width=80%}\n:::\n:::\n\n\nPuede ocurrir que necesitemos reutilizar el gráfico. Hacer la gran *stackoverflow* (copiar y pegar el código) es una opción, pero puede generar errores y por otro lado implica tiempo de procesamiento.\n\nEn cambio, con la opción `ref.label` podemos reutilizar lo que hicimos antes, de una forma más prolija y cómoda pasando el nombre del bloque anterior.\n\nInternamente, lo que hace R es reutilizar el código creado anteriormente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n{r ref.label=\"grafico1\"}\n```\n:::\n\n\nVoilá!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(enc, aes(x = pais, fill = resultado)) +\n  geom_bar(position = \"fill\") +\n  scale_fill_manual(values = c(color3)) +\n  estiloh +\n  eje_y_per +\n  labs(title = \"Resultados por país\",\n       fill = \"Resultado\",\n       x = \"\", y = \"\",\n       caption = fuente)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=80%}\n:::\n:::\n\n\n## Etiquetas largas\n\nA veces necesitamos presentar en un gráfico o en una tabla la pregunta original de la encuesta. Por ejemplo, una de las \"preguntas\" de la encuesta dice:\n\n> *Otra pregunta que tiene muchísimo texto escrito en la encuesta y quedó tan larga que no entra en un solo renglón y que me hace preguntarme cómo la voy a poner en un gráfico*\n\nAhora veamos cómo se ven las preguntas en un gráfico si intentamos hacer un ranking.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenc %>% \n  group_by(pregunta, resultado) %>% \n  summarise(cant = n()) %>% \n  mutate(prop = cant/sum(cant)) %>% \n  filter(resultado == \"Positivo\") %>% \n  ggplot(aes(x = prop, y = pregunta)) +\n  geom_col(fill = verde) +\n  estilov +\n  eje_x_per +\n  labs(title = \"Ranking de Respuestas Positivas\",\n       x = \"\", y = \"\",\n       caption = fuente)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/etiq-largas-1.png){width=80%}\n:::\n:::\n\n\nQueda hermoso, no? 😱\n\nPara sortear este problema podemos crear una columna nueva, y usar la función `str_wrap()` del paquete *stringr*.\n\nLo que hace esto es agregar el símbolo `\\n` que divide el texto en renglones. Con el parámetro `width` le indicamos la cantidad de caracteres de largo que tendrá cada renglón.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Divide el largo de 'función' en varias líneas\nenc$preg2 <- str_wrap(enc$pregunta, width = 40)\n\n# Veamos como queda esto en el df\nhead(enc$preg2,5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Una pregunta con un texto muy pero muy\\npero muy largo, de verdad que es muy muy\\nmuy largo\"                                                                                     \n[2] \"Otra pregunta que tiene muchísimo texto\\nescrito en la encuesta y quedó tan larga\\nque no entra en un solo renglón y que me\\nhace preguntarme cómo la voy a poner en\\nun gráfico\"\n[3] \"Los líderes son unos capos\"                                                                                                                                                      \n[4] \"Que grosso es trabajar acá\"                                                                                                                                                      \n[5] \"Esta encuesta es genial\"                                                                                                                                                         \n```\n:::\n:::\n\n\nY ahora podemos hacer un gráfico que se vea bien:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenc %>% \n  group_by(preg2, resultado) %>% \n  summarise(cant = n()) %>% \n  mutate(prop = cant/sum(cant)) %>% \n  filter(resultado == \"Positivo\") %>% \n  ggplot(aes(x = prop, y = reorder(preg2, prop))) +\n  geom_col(fill = verde) +\n  estilov +\n  eje_x_per +\n  labs(title = \"Ranking de Respuestas Positivas\",\n       x = \"\", y = \"\",\n       caption = fuente)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/etiq-largas2-1.png){width=80%}\n:::\n:::\n\n\nAhora queda mucho mejor 👍\n\nTambién se puede jugar con la altura del gráfico usando la opción `fig.height` en las opciones del bloque para que haya más espacio entre las barras.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n{r fig.height=8} # El tamaño es exagerado en este caso\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nranking <- enc %>% \n  group_by(preg2, resultado) %>% \n  summarise(cant = n()) %>% \n  mutate(prop = cant/sum(cant)) %>% \n  filter(resultado == \"Positivo\") %>% \n  ggplot(aes(x = prop, y = reorder(preg2, prop))) +\n  geom_col(fill = verde) +\n  estilov +\n  eje_x_per +\n  labs(title = \"Ranking de Respuestas Positivas\",\n       x = \"\", y = \"\",\n       caption = fuente)\n\nranking\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/etiq-largas3-1.png){width=80%}\n:::\n:::\n\n\n## Texto en los gráficos\n\nEs simple agregar las etiquetas de datos a un gráfico:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nranking +\n  geom_text(aes(label = percent(prop, # Muestra los resultados como porcentaje\n                                accuracy = 1)), # Indica la cantidad de decimales\n            size = 3,                           # Cambia el tamaño de la letra\n            hjust = 1.2,                        # Mueve la etiqueta para la izquierda\n            family = \"Ubuntu Mono\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/texto1-1.png){width=80%}\n:::\n:::\n\n\nMiremos lo que pasa cuando queremos agregar más información al gráfico, por ejemplo, con los resultados por país.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nranking <- enc %>% \n  group_by(pais, preg2, resultado) %>% \n  summarise(cant = n()) %>% \n  mutate(prop = cant/sum(cant)) %>% \n  filter(resultado == \"Positivo\") %>% \n  ggplot(aes(x = prop, y = reorder(preg2, prop), fill = pais)) +\n  geom_col(position = \"dodge\") +\n  estilov +\n  eje_x_per +\n  labs(title = \"Ranking de Respuestas Positivas\",\n       x = \"\", y = \"\",\n       fill = \"País\",\n       caption = fuente) +\n  scale_fill_brewer(palette = 2)\n\nranking +\n   geom_text(aes(label = percent(prop, # Muestra los resultados como porcentaje\n                                accuracy = 1)), # Indica la cantidad de decimales\n            size = 3,                           # Cambia el tamaño de la letra\n            hjust = 1.2,                        # Mueve la etiqueta para la izquierda\n            family = \"Ubuntu Mono\")             # Modifica la fuente\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/texto2-1.png){width=80%}\n:::\n:::\n\n\nEl problema es que todas las etiquetas de cada barra están centradas con la etiqueta del eje *y*. En la guía de `geom_text` en la documentación de `ggplot2` [encontramos como solucionar el problema](https://ggplot2.tidyverse.org/reference/geom_text.html) usando el parámetro `position_dodge()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nranking <- ranking +\n   geom_text(aes(label = percent(prop, # Muestra los resultados como porcentaje\n                                accuracy = 1)), # Indica la cantidad de decimales\n            position = position_dodge(0.9),     # Acomoda cada etiqueta con las barras\n            size = 3,                           # Cambia el tamaño de la letra\n            hjust = 1.2,                        # Mueve la etiqueta para la izquierda\n            family = \"Ubuntu Mono\")             # Modifica la fuente\n\nranking\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/text3-1.png){width=80%}\n:::\n:::\n\n\nOtra mejora que podemos hacer al gráfico es acomodar los colores en la leyenda (la referencia de los colores) para que tengan la misma secuencia que tiene en el gráfico, es decir que el verde oscuro aparezca primero al igual que la barra con el verde más oscuro en el gráfico.\n\nEn [esta página](https://www.datanovia.com/en/blog/ggplot-legend-title-position-and-labels/) hay muchas variantes para trabajar con las etiquetas y leyendas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nranking +\n  guides(fill = guide_legend(reverse=TRUE)) + # Invierte el orden de los colores en la leyenda\n  theme(axis.text.x = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/texto4-1.png){width=80%}\n:::\n:::\n\n\nCuando estamos mapeando una variable categórica en el eje *y*, R lo ordena alfabéticamente desde *abajo* **hacia** *arriba*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenc %>% \n  group_by(sector, resultado) %>% \n  summarise(cant = n()) %>% \n  mutate(prop = cant/sum(cant)) %>% \n  filter(resultado == \"Positivo\") %>% \n  ggplot(aes(x = prop, y = sector)) +\n  geom_col(fill = verde) +\n  estilov +\n  eje_x_per +\n  labs(title = \"Resultado Positivos por Sector\",\n       x = \"\", y = \"\",\n       caption = fuente)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/textoy-1.png){width=80%}\n:::\n:::\n\n\nPodemos usar la función `fct_rev` del paquete *forcats* para poner al revés las etiquetas del eje *y* cuando estamos mapeando las variables dentro de `ggplot`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenc %>% \n  group_by(sector, resultado) %>% \n  summarise(cant = n()) %>% \n  mutate(prop = cant/sum(cant)) %>% \n  filter(resultado == \"Positivo\") %>% \n  ggplot(aes(x = prop, y = fct_rev(sector))) + # Invertimos el orden del eje y\n  geom_col(fill = verde) +\n  estilov +\n  eje_x_per +\n  labs(title = \"Resultado Positivos por Sector\",\n       x = \"\", y = \"\",\n       caption = fuente)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/textoy2-1.png){width=80%}\n:::\n:::\n\n\n## Funciones\n\nEsto es un *work-in-progress* y tengo que agradecer a [Mónica Alonso](https://twitter.com/MonicaLA2000) de RLadies Buenos Aires por la ayuda.\n\nEl problema es que me encontré muchas veces escribiendo esta secuencia de código muchas veces:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calcular pocertajes de respuestas\nenc %>% \n  group_by(genero, resultado) %>% \n  summarise(cant = n()) %>% \n  mutate(prop = cant / sum(cant))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n# Groups:   genero [2]\n  genero    resultado  cant   prop\n  <chr>     <fct>     <int>  <dbl>\n1 Femenino  Positivo   1127 0.764 \n2 Femenino  Neutral     244 0.165 \n3 Femenino  Negativo    104 0.0705\n4 Masculino Positivo   1477 0.823 \n5 Masculino Neutral     222 0.124 \n6 Masculino Negativo     96 0.0535\n```\n:::\n:::\n\n\nMuchas veces resolví copiando y pegando el código, pero se hace tedioso controlar cada uno de los bloques de código y gráficos. Así que para eso, podemos crear nuestras propias funciones.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncant_prop_gen <- function(df){\n  df %>% \n    group_by(genero,resultado) %>% \n    summarise(cant = n()) %>% \n    mutate(prop = cant / sum(cant)) \n}\n```\n:::\n\n\nY ahora lo podemos incorporar en nuestro flujo de trabajo como cualquier función.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenc %>% \n  cant_prop_gen() %>% \n  ggplot(aes(x = genero, y = prop, fill = resultado)) +\n  geom_col(position = \"dodge\") +\n  eje_y_per +\n  estiloh +\n  scale_fill_manual(values = color3) +\n  labs(title = \"Resultados por Género\",\n       x = \"\", y = \"\",\n       fill = \"Resultado\",\n       caption = fuente)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/fun3-1.png){width=80%}\n:::\n:::\n\n\nTodavía estoy resolviendo como crear funciones usando cualquier tipo de variable en la función. Por ahora, lo estoy resolviendo creando una función para cada combinación de variables que agrupo. No es lo ideal, pero es lo que hay. 🤷\n\nCapaz encuentre lo que necesito en estos libros:\n\n-   [R para Ciencia de Datos](https://es.r4ds.hadley.nz/)\n-   [Hands-On Programming with R](https://rstudio-education.github.io/hopr/)\n-   [Advanced R](https://adv-r.hadley.nz/index.html)\n\nYa les contaré... stay tuned 📺\n\n## Código Inline\n\nComo sabemos, algo interesante de RMarkdown es la posibilidad de utilizar el código de los bloques dentro del texto.\n\nAsí que creemos un pequeño objeto primero para almacenar los resultados positivos y negativos por género.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_genero <- enc %>% \n  cant_prop_gen()\n\nresult_genero\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 × 4\n# Groups:   genero [2]\n  genero    resultado  cant   prop\n  <chr>     <fct>     <int>  <dbl>\n1 Femenino  Positivo   1127 0.764 \n2 Femenino  Neutral     244 0.165 \n3 Femenino  Negativo    104 0.0705\n4 Masculino Positivo   1477 0.823 \n5 Masculino Neutral     222 0.124 \n6 Masculino Negativo     96 0.0535\n```\n:::\n:::\n\n\nUsando la llamada de datos de un dataframe con `nombre_df[fila,columna]` puedo usar los resultados almacenados para incluirlos dentro del texto por ejemplo para decir:\n\n*Los resultados positivos para las personas de género femenino es 0.7640678*.\n\nLo ideal es poder ver ese resultado como un porcentaje, así que intuitivamente podemos usar la función `percent` para lograr eso...\n\n...y no va a funcionar. Obtenemos el siguiente mensaje de error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Intento de código inline\n`r percent(result_genero[1,4])`\n\n# Quitting from lines 425-441 (r4hr_microaprendizajes.Rmd) \n# Error in is.finite(x) : default method not implemented for type 'list'\n```\n:::\n\n\nPara que la función `percent` funcione la tenemos que combinar con la función `pull` . Y ahora así sí funciona:\n\n*Los resultados positivos para las personas de género femenino es 76%* .\n\n## *Trust the Tidyverse*\n\n> *Lo barato sale caro*\n>\n> Dicho popular\n\n![](https://linternasybosques.files.wordpress.com/2018/10/meme-no-creas.png){width=\"300\"}\n\nLa encuesta que estábamos analizando era anónima, lo cual hacía imposible poder cruzar datos contra el listado de empleados.\n\nPero, sí podíamos calcular los resultados según la composición del liderazgo. Para eso teníamos que calcular el porcentaje de líderes hombres y mujeres por sector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cuento la cantidad de líderes por sector y géenero\nplantel <- plantel %>% \n  rename(division = `Unidad de Negocio`, \n         lider = Líder, \n         sexo = Género, \n         sector = Sector, \n         pais = País) %>% \n  filter(lider == \"true\") %>% \n  group_by(pais, division, sector, lider, sexo) %>% \n  tally() %>% \n  ungroup()\n\nplantel\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 106 × 6\n   pais  division sector           lider sexo          n\n   <chr> <chr>    <chr>            <chr> <chr>     <int>\n 1 Chad  Unidad 1 Comercial        true  Femenino      4\n 2 Chad  Unidad 1 Comercial        true  Masculino     3\n 3 Chad  Unidad 1 R&D              true  Femenino      5\n 4 Chad  Unidad 1 R&D              true  Masculino     1\n 5 Chad  Unidad 2 Administración   true  Femenino      3\n 6 Chad  Unidad 2 Administración   true  Masculino     6\n 7 Chad  Unidad 2 Calidad          true  Femenino      1\n 8 Chad  Unidad 2 Comercial        true  Femenino      5\n 9 Chad  Unidad 2 Comercial        true  Masculino     1\n10 Chad  Unidad 2 Recursos Humanos true  Femenino      3\n# ℹ 96 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pivoteo el dataset a un dataset ancho\nplantel <- plantel %>% \n  pivot_wider(.,\n              names_from = sexo,\n              values_from = n)\n\n# Reemplaza los NA con un 0\nplantel[is.na(plantel)] <- 0\n\n\n# Calculo porcentaje de líderes hombres\nplantel %>% \n  mutate(prop_lider_hombre = if_else(Femenino == 0, 1, Masculino / (Masculino +Femenino))) %>% \n  select(-lider)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 60 × 6\n   pais  division sector           Femenino Masculino prop_lider_hombre\n   <chr> <chr>    <chr>               <int>     <int>             <dbl>\n 1 Chad  Unidad 1 Comercial               4         3             0.429\n 2 Chad  Unidad 1 R&D                     5         1             0.167\n 3 Chad  Unidad 2 Administración          3         6             0.667\n 4 Chad  Unidad 2 Calidad                 1         0             0    \n 5 Chad  Unidad 2 Comercial               5         1             0.167\n 6 Chad  Unidad 2 Recursos Humanos        3         0             0    \n 7 Chad  Unidad 3 Administración          2         2             0.5  \n 8 Chad  Unidad 3 Calidad                 2         2             0.5  \n 9 Chad  Unidad 3 Comercial               5        20             0.8  \n10 Chad  Unidad 3 HSE                     1         0             0    \n# ℹ 50 more rows\n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}