{
  "hash": "e863f985bd1314b09c194fe993770721",
  "result": {
    "markdown": "---\ntitle: \"Microaprendizajes de un proyecto\"\ndate: \"22/05/2021\"\nauthor: \"Checho\"\ncategories: [ggplot2, tipito, tip, visualizaci√≥n, rmarkdown]\n---\n\n\n# Introducci√≥n\n\nEsta presentaci√≥n se centra en algunos *microaprendizajes* de un proyecto de an√°lisis de resultados de una encuesta de diversidad e inclusi√≥n.\n\nLo raz√≥n por la que lo llamo *\"microaprendizajes\"* es porque no tuve que aprender muchas cosas desde cero, pero si aprend√≠ varios truquitos que me sirvieron mucho.\n\nVoy a usar una encuesta simulada para no violar la confidencialidad de los datos, pero va a ser algo an√°logo a lo que estuve usando en el proyecto.\n\nPara explotar al m√°ximo esta sesi√≥n conviene saber un poco de hacer informes con RMarkdown. Si necesit√°s un tutorial sobre ese tema te comparto el [video que hicimos el a√±o pasado](https://youtu.be/KT4UfTqAYoU).\n\n### ![](https://media.npr.org/assets/img/2023/05/26/honest-work-meme-cb0f0fb2227fb84b77b3c9a851ac09b095ab74d8-s1100-c50.jpg){width=\"395\"}\n\n### `<svg aria-hidden=\"true\" role=\"img\" viewBox=\"0 0 496 512\" style=\"height:1em;width:0.97em;vertical-align:-0.125em;margin-left:auto;margin-right:auto;font-size:inherit;fill:steelblue;overflow:visible;position:relative;\"><path d=\"M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z\"/></svg>`{=html} [Repo](https://github.com/r4hr/r4hr_microaprendizajes)\n\nEste material se puede utilizar y compartir sin fines comerciales y citando la fuente.\n\n![Licencia](https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/Cc-by-nc_icon.svg/1200px-Cc-by-nc_icon.svg)\n\n# Aprendizajes\n\n## El *chunk* de 'setup'\n\nEl bloque de c√≥digo de `setup` es muy √∫til para controlar c√≥mo se van a comportar todos los bloques de c√≥digo.\n\nMi archivo original tiene +150 bloques de c√≥digo, imaginen si modificara uno por uno las caracter√≠sticas de cada bloque.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nknitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, fig.retina = 3,\n                      out.width = \"80%\")\n```\n:::\n\n\n## Ordenar el c√≥digo\n\nTener un orden en el c√≥digo es muy importante para poder ir y venir r√°pido y encontrar r√°pidamente las cosas, modificar algo, y dem√°s.\n\nDentro de los bloques de c√≥digo tambi√©n es importante poner t√≠tulos o marcadores que nos ayuden a encontrar r√°pido las cosas. El orden que defin√≠ fue:\n\n1.  Librer√≠as.\n2.  Configuraciones generales\n3.  Carga de datos\n4.  Preprocesamiento y limpieza de datos\n5.  Funciones\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Librer√≠as -----\nlibrary(tidyverse)\nlibrary(gt)\nlibrary(scales)\nlibrary(extrafont)\nlibrary(readxl)\n\n\n# Configuraciones generales ----------\n\n# Colores\nverde <- \"#01B3B6\"\nnegro <- \"#333132\"\ngris <- \"#AEB6BF\"\n\ncolor3 <- c(verde, gris, negro)\ncolor2 <- c(verde, negro)\n\n# Opciones de visualizaci√≥n --------\noptions(scipen = 999)   # Modifica la visualizaci√≥n de los ejes num√©rico a valores nominales\n\nloadfonts(quiet = TRUE) # Permite cargar en R otros tipos de fuentes.\n\n# Estilo limpio sin l√≠neas de fondo\nestilo <- theme(panel.grid = element_blank(),\n                plot.background = element_rect(fill = \"#FBFCFC\"),\n                panel.background = element_blank(),\n                text = element_text(family = \"Ubuntu Mono\"))\n\n# Estilo limpio con l√≠neas de referencia verticales en gris claro\nestilov <- theme(panel.grid = element_blank(),\n                 plot.background = element_rect(fill = \"#FBFCFC\"),\n                 panel.background = element_blank(),\n                 panel.grid.major.x = element_line(color = \"#ecf0f1\"),\n                 text = element_text(family = \"Ubuntu Mono\"))\n\n# Estilo limpio con l√≠neas de referencia horizontales en gris claro\nestiloh <- theme(panel.grid = element_blank(),\n                 plot.background = element_rect(fill = \"#FBFCFC\"),\n                 panel.background = element_blank(),\n                 panel.grid.major.y = element_line(color = \"#ecf0f1\"),\n                 text = element_text(family = \"Ubuntu Mono\"))\n\n\n# Creo un objeto con un texto que se va a repetir mucho a lo largo del an√°lisis\nfuente <- \"Club de R para RRHH\\nDatos Ficticios\"\n\n# Creo objetos para formatear las etiquetas num√©ricas de los ejes x e y\neje_x_per <- scale_x_continuous(labels = scales::percent_format(accuracy = 1))\n\neje_y_per <- scale_y_continuous(labels = scales::percent_format(accuracy = 1))\n\n# Carga de Datos -----\nencuesta <- read_excel(\"data/encuesta.xlsx\")\nplantel  <- read_excel(\"data/plantel.xlsx\")\n\n# Preparaci√≥n de datos -----------\n\n# Pivotea el dataset a un formato largo\nenc <- encuesta %>% \n  pivot_longer(cols = c(7:11),\n               names_to = \"pregunta\", \n               values_to = \"valor\")\n\n# Cambia nombres y Organiza variables ordinales \n\nenc <- enc %>% \n  rename(id = \"ID\",\n         genero = `¬øC√≥mo definir√≠as tu identidad de g√©nero?`,\n         unidad = \"Unidad de Negocio\",\n         pais = \"Pa√≠s\",\n         sector = \"Sector\",\n         cargo = \"Tu cargo/nivel:\") %>% \n  mutate(cargo = factor(cargo,\n                        levels = c(\"Management\", \"L√≠der\", \"Contribuidor individual\")))\n\n# Crea categor√≠as de resultados\n\nenc <- enc %>% \n  mutate(resultado = if_else(valor == \"Totalmente de acuerdo\", \"Positivo\", \n                             if_else(valor == \"De acuerdo\", \"Positivo\", \n                                     if_else(valor == \"Ni de acuerdo ni en desacuerdo\",\n                                             \"Neutral\", \"Negativo\"\n      )\n    )\n  ),\n         resultado = factor(resultado, \n                            levels = c(\"Positivo\", \"Neutral\", \"Negativo\")))\n```\n:::\n\n\n> Y comenten el c√≥digo por amor a Jeb√∫s!\n\n![](files/comenten.png){width=\"300\"}\n\n## Poner el nombre a los bloques de c√≥digo\n\nAlgo muy √∫til es ponerle nombre a los bloques de c√≥digo. Por un lado porque es f√°cil para navegar entre bloques busc√°ndolos en RStudio.\n\nPor ejemplo, probemos un gr√°fico simple:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(enc, aes(x = pais, fill = resultado)) +\n  geom_bar(position = \"fill\") +\n  scale_fill_manual(values = c(color3)) +\n  estiloh +\n  eje_y_per +\n  labs(title = \"Resultados por pa√≠s\",\n       fill = \"Resultado\",\n       x = \"\", y = \"\",\n       caption = fuente)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/grafico1-1.png){width=80%}\n:::\n:::\n\n\nPuede ocurrir que necesitemos reutilizar el gr√°fico. Hacer la gran *stackoverflow* (copiar y pegar el c√≥digo) es una opci√≥n, pero puede generar errores y por otro lado implica tiempo de procesamiento.\n\nEn cambio, con la opci√≥n `ref.label` podemos reutilizar lo que hicimos antes, de una forma m√°s prolija y c√≥moda pasando el nombre del bloque anterior.\n\nInternamente, lo que hace R es reutilizar el c√≥digo creado anteriormente.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n{r ref.label=\"grafico1\"}\n```\n:::\n\n\nVoil√°!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(enc, aes(x = pais, fill = resultado)) +\n  geom_bar(position = \"fill\") +\n  scale_fill_manual(values = c(color3)) +\n  estiloh +\n  eje_y_per +\n  labs(title = \"Resultados por pa√≠s\",\n       fill = \"Resultado\",\n       x = \"\", y = \"\",\n       caption = fuente)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-1-1.png){width=80%}\n:::\n:::\n\n\n## Etiquetas largas\n\nA veces necesitamos presentar en un gr√°fico o en una tabla la pregunta original de la encuesta. Por ejemplo, una de las \"preguntas\" de la encuesta dice:\n\n> *Otra pregunta que tiene much√≠simo texto escrito en la encuesta y qued√≥ tan larga que no entra en un solo rengl√≥n y que me hace preguntarme c√≥mo la voy a poner en un gr√°fico*\n\nAhora veamos c√≥mo se ven las preguntas en un gr√°fico si intentamos hacer un ranking.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenc %>% \n  group_by(pregunta, resultado) %>% \n  summarise(cant = n()) %>% \n  mutate(prop = cant/sum(cant)) %>% \n  filter(resultado == \"Positivo\") %>% \n  ggplot(aes(x = prop, y = pregunta)) +\n  geom_col(fill = verde) +\n  estilov +\n  eje_x_per +\n  labs(title = \"Ranking de Respuestas Positivas\",\n       x = \"\", y = \"\",\n       caption = fuente)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/etiq-largas-1.png){width=80%}\n:::\n:::\n\n\nQueda hermoso, no? üò±\n\nPara sortear este problema podemos crear una columna nueva, y usar la funci√≥n `str_wrap()` del paquete *stringr*.\n\nLo que hace esto es agregar el s√≠mbolo `\\n` que divide el texto en renglones. Con el par√°metro `width` le indicamos la cantidad de caracteres de largo que tendr√° cada rengl√≥n.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Divide el largo de 'funci√≥n' en varias l√≠neas\nenc$preg2 <- str_wrap(enc$pregunta, width = 40)\n\n# Veamos como queda esto en el df\nhead(enc$preg2,5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Una pregunta con un texto muy pero muy\\npero muy largo, de verdad que es muy muy\\nmuy largo\"                                                                                     \n[2] \"Otra pregunta que tiene much√≠simo texto\\nescrito en la encuesta y qued√≥ tan larga\\nque no entra en un solo rengl√≥n y que me\\nhace preguntarme c√≥mo la voy a poner en\\nun gr√°fico\"\n[3] \"Los l√≠deres son unos capos\"                                                                                                                                                      \n[4] \"Que grosso es trabajar ac√°\"                                                                                                                                                      \n[5] \"Esta encuesta es genial\"                                                                                                                                                         \n```\n:::\n:::\n\n\nY ahora podemos hacer un gr√°fico que se vea bien:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenc %>% \n  group_by(preg2, resultado) %>% \n  summarise(cant = n()) %>% \n  mutate(prop = cant/sum(cant)) %>% \n  filter(resultado == \"Positivo\") %>% \n  ggplot(aes(x = prop, y = reorder(preg2, prop))) +\n  geom_col(fill = verde) +\n  estilov +\n  eje_x_per +\n  labs(title = \"Ranking de Respuestas Positivas\",\n       x = \"\", y = \"\",\n       caption = fuente)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/etiq-largas2-1.png){width=80%}\n:::\n:::\n\n\nAhora queda mucho mejor üëç\n\nTambi√©n se puede jugar con la altura del gr√°fico usando la opci√≥n `fig.height` en las opciones del bloque para que haya m√°s espacio entre las barras.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n{r fig.height=8} # El tama√±o es exagerado en este caso\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nranking <- enc %>% \n  group_by(preg2, resultado) %>% \n  summarise(cant = n()) %>% \n  mutate(prop = cant/sum(cant)) %>% \n  filter(resultado == \"Positivo\") %>% \n  ggplot(aes(x = prop, y = reorder(preg2, prop))) +\n  geom_col(fill = verde) +\n  estilov +\n  eje_x_per +\n  labs(title = \"Ranking de Respuestas Positivas\",\n       x = \"\", y = \"\",\n       caption = fuente)\n\nranking\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/etiq-largas3-1.png){width=80%}\n:::\n:::\n\n\n## Texto en los gr√°ficos\n\nEs simple agregar las etiquetas de datos a un gr√°fico:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nranking +\n  geom_text(aes(label = percent(prop, # Muestra los resultados como porcentaje\n                                accuracy = 1)), # Indica la cantidad de decimales\n            size = 3,                           # Cambia el tama√±o de la letra\n            hjust = 1.2,                        # Mueve la etiqueta para la izquierda\n            family = \"Ubuntu Mono\") \n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/texto1-1.png){width=80%}\n:::\n:::\n\n\nMiremos lo que pasa cuando queremos agregar m√°s informaci√≥n al gr√°fico, por ejemplo, con los resultados por pa√≠s.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nranking <- enc %>% \n  group_by(pais, preg2, resultado) %>% \n  summarise(cant = n()) %>% \n  mutate(prop = cant/sum(cant)) %>% \n  filter(resultado == \"Positivo\") %>% \n  ggplot(aes(x = prop, y = reorder(preg2, prop), fill = pais)) +\n  geom_col(position = \"dodge\") +\n  estilov +\n  eje_x_per +\n  labs(title = \"Ranking de Respuestas Positivas\",\n       x = \"\", y = \"\",\n       fill = \"Pa√≠s\",\n       caption = fuente) +\n  scale_fill_brewer(palette = 2)\n\nranking +\n   geom_text(aes(label = percent(prop, # Muestra los resultados como porcentaje\n                                accuracy = 1)), # Indica la cantidad de decimales\n            size = 3,                           # Cambia el tama√±o de la letra\n            hjust = 1.2,                        # Mueve la etiqueta para la izquierda\n            family = \"Ubuntu Mono\")             # Modifica la fuente\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/texto2-1.png){width=80%}\n:::\n:::\n\n\nEl problema es que todas las etiquetas de cada barra est√°n centradas con la etiqueta del eje *y*. En la gu√≠a de `geom_text` en la documentaci√≥n de `ggplot2` [encontramos como solucionar el problema](https://ggplot2.tidyverse.org/reference/geom_text.html) usando el par√°metro `position_dodge()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nranking <- ranking +\n   geom_text(aes(label = percent(prop, # Muestra los resultados como porcentaje\n                                accuracy = 1)), # Indica la cantidad de decimales\n            position = position_dodge(0.9),     # Acomoda cada etiqueta con las barras\n            size = 3,                           # Cambia el tama√±o de la letra\n            hjust = 1.2,                        # Mueve la etiqueta para la izquierda\n            family = \"Ubuntu Mono\")             # Modifica la fuente\n\nranking\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/text3-1.png){width=80%}\n:::\n:::\n\n\nOtra mejora que podemos hacer al gr√°fico es acomodar los colores en la leyenda (la referencia de los colores) para que tengan la misma secuencia que tiene en el gr√°fico, es decir que el verde oscuro aparezca primero al igual que la barra con el verde m√°s oscuro en el gr√°fico.\n\nEn [esta p√°gina](https://www.datanovia.com/en/blog/ggplot-legend-title-position-and-labels/) hay muchas variantes para trabajar con las etiquetas y leyendas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nranking +\n  guides(fill = guide_legend(reverse=TRUE)) + # Invierte el orden de los colores en la leyenda\n  theme(axis.text.x = element_blank())\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/texto4-1.png){width=80%}\n:::\n:::\n\n\nCuando estamos mapeando una variable categ√≥rica en el eje *y*, R lo ordena alfab√©ticamente desde *abajo* **hacia** *arriba*.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenc %>% \n  group_by(sector, resultado) %>% \n  summarise(cant = n()) %>% \n  mutate(prop = cant/sum(cant)) %>% \n  filter(resultado == \"Positivo\") %>% \n  ggplot(aes(x = prop, y = sector)) +\n  geom_col(fill = verde) +\n  estilov +\n  eje_x_per +\n  labs(title = \"Resultado Positivos por Sector\",\n       x = \"\", y = \"\",\n       caption = fuente)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/textoy-1.png){width=80%}\n:::\n:::\n\n\nPodemos usar la funci√≥n `fct_rev` del paquete *forcats* para poner al rev√©s las etiquetas del eje *y* cuando estamos mapeando las variables dentro de `ggplot`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenc %>% \n  group_by(sector, resultado) %>% \n  summarise(cant = n()) %>% \n  mutate(prop = cant/sum(cant)) %>% \n  filter(resultado == \"Positivo\") %>% \n  ggplot(aes(x = prop, y = fct_rev(sector))) + # Invertimos el orden del eje y\n  geom_col(fill = verde) +\n  estilov +\n  eje_x_per +\n  labs(title = \"Resultado Positivos por Sector\",\n       x = \"\", y = \"\",\n       caption = fuente)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/textoy2-1.png){width=80%}\n:::\n:::\n\n\n## Funciones\n\nEsto es un *work-in-progress* y tengo que agradecer a [M√≥nica Alonso](https://twitter.com/MonicaLA2000) de RLadies Buenos Aires por la ayuda.\n\nEl problema es que me encontr√© muchas veces escribiendo esta secuencia de c√≥digo muchas veces:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Calcular pocertajes de respuestas\nenc %>% \n  group_by(genero, resultado) %>% \n  summarise(cant = n()) %>% \n  mutate(prop = cant / sum(cant))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 √ó 4\n# Groups:   genero [2]\n  genero    resultado  cant   prop\n  <chr>     <fct>     <int>  <dbl>\n1 Femenino  Positivo   1127 0.764 \n2 Femenino  Neutral     244 0.165 \n3 Femenino  Negativo    104 0.0705\n4 Masculino Positivo   1477 0.823 \n5 Masculino Neutral     222 0.124 \n6 Masculino Negativo     96 0.0535\n```\n:::\n:::\n\n\nMuchas veces resolv√≠ copiando y pegando el c√≥digo, pero se hace tedioso controlar cada uno de los bloques de c√≥digo y gr√°ficos. As√≠ que para eso, podemos crear nuestras propias funciones.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncant_prop_gen <- function(df){\n  df %>% \n    group_by(genero,resultado) %>% \n    summarise(cant = n()) %>% \n    mutate(prop = cant / sum(cant)) \n}\n```\n:::\n\n\nY ahora lo podemos incorporar en nuestro flujo de trabajo como cualquier funci√≥n.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nenc %>% \n  cant_prop_gen() %>% \n  ggplot(aes(x = genero, y = prop, fill = resultado)) +\n  geom_col(position = \"dodge\") +\n  eje_y_per +\n  estiloh +\n  scale_fill_manual(values = color3) +\n  labs(title = \"Resultados por G√©nero\",\n       x = \"\", y = \"\",\n       fill = \"Resultado\",\n       caption = fuente)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/fun3-1.png){width=80%}\n:::\n:::\n\n\nTodav√≠a estoy resolviendo como crear funciones usando cualquier tipo de variable en la funci√≥n. Por ahora, lo estoy resolviendo creando una funci√≥n para cada combinaci√≥n de variables que agrupo. No es lo ideal, pero es lo que hay. ü§∑\n\nCapaz encuentre lo que necesito en estos libros:\n\n-   [R para Ciencia de Datos](https://es.r4ds.hadley.nz/)\n-   [Hands-On Programming with R](https://rstudio-education.github.io/hopr/)\n-   [Advanced R](https://adv-r.hadley.nz/index.html)\n\nYa les contar√©... stay tuned üì∫\n\n## C√≥digo Inline\n\nComo sabemos, algo interesante de RMarkdown es la posibilidad de utilizar el c√≥digo de los bloques dentro del texto.\n\nAs√≠ que creemos un peque√±o objeto primero para almacenar los resultados positivos y negativos por g√©nero.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult_genero <- enc %>% \n  cant_prop_gen()\n\nresult_genero\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 6 √ó 4\n# Groups:   genero [2]\n  genero    resultado  cant   prop\n  <chr>     <fct>     <int>  <dbl>\n1 Femenino  Positivo   1127 0.764 \n2 Femenino  Neutral     244 0.165 \n3 Femenino  Negativo    104 0.0705\n4 Masculino Positivo   1477 0.823 \n5 Masculino Neutral     222 0.124 \n6 Masculino Negativo     96 0.0535\n```\n:::\n:::\n\n\nUsando la llamada de datos de un dataframe con `nombre_df[fila,columna]` puedo usar los resultados almacenados para incluirlos dentro del texto por ejemplo para decir:\n\n*Los resultados positivos para las personas de g√©nero femenino es 0.7640678*.\n\nLo ideal es poder ver ese resultado como un porcentaje, as√≠ que intuitivamente podemos usar la funci√≥n `percent` para lograr eso...\n\n...y no va a funcionar. Obtenemos el siguiente mensaje de error:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Intento de c√≥digo inline\n`r percent(result_genero[1,4])`\n\n# Quitting from lines 425-441 (r4hr_microaprendizajes.Rmd) \n# Error in is.finite(x) : default method not implemented for type 'list'\n```\n:::\n\n\nPara que la funci√≥n `percent` funcione la tenemos que combinar con la funci√≥n `pull` . Y ahora as√≠ s√≠ funciona:\n\n*Los resultados positivos para las personas de g√©nero femenino es 76%* .\n\n## *Trust the Tidyverse*\n\n> *Lo barato sale caro*\n>\n> Dicho popular\n\n![](https://linternasybosques.files.wordpress.com/2018/10/meme-no-creas.png){width=\"300\"}\n\nLa encuesta que est√°bamos analizando era an√≥nima, lo cual hac√≠a imposible poder cruzar datos contra el listado de empleados.\n\nPero, s√≠ pod√≠amos calcular los resultados seg√∫n la composici√≥n del liderazgo. Para eso ten√≠amos que calcular el porcentaje de l√≠deres hombres y mujeres por sector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Cuento la cantidad de l√≠deres por sector y g√©enero\nplantel <- plantel %>% \n  rename(division = `Unidad de Negocio`, \n         lider = L√≠der, \n         sexo = G√©nero, \n         sector = Sector, \n         pais = Pa√≠s) %>% \n  filter(lider == \"true\") %>% \n  group_by(pais, division, sector, lider, sexo) %>% \n  tally() %>% \n  ungroup()\n\nplantel\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 106 √ó 6\n   pais  division sector           lider sexo          n\n   <chr> <chr>    <chr>            <chr> <chr>     <int>\n 1 Chad  Unidad 1 Comercial        true  Femenino      4\n 2 Chad  Unidad 1 Comercial        true  Masculino     3\n 3 Chad  Unidad 1 R&D              true  Femenino      5\n 4 Chad  Unidad 1 R&D              true  Masculino     1\n 5 Chad  Unidad 2 Administraci√≥n   true  Femenino      3\n 6 Chad  Unidad 2 Administraci√≥n   true  Masculino     6\n 7 Chad  Unidad 2 Calidad          true  Femenino      1\n 8 Chad  Unidad 2 Comercial        true  Femenino      5\n 9 Chad  Unidad 2 Comercial        true  Masculino     1\n10 Chad  Unidad 2 Recursos Humanos true  Femenino      3\n# ‚Ñπ 96 more rows\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Pivoteo el dataset a un dataset ancho\nplantel <- plantel %>% \n  pivot_wider(.,\n              names_from = sexo,\n              values_from = n)\n\n# Reemplaza los NA con un 0\nplantel[is.na(plantel)] <- 0\n\n\n# Calculo porcentaje de l√≠deres hombres\nplantel %>% \n  mutate(prop_lider_hombre = if_else(Femenino == 0, 1, Masculino / (Masculino +Femenino))) %>% \n  select(-lider)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 60 √ó 6\n   pais  division sector           Femenino Masculino prop_lider_hombre\n   <chr> <chr>    <chr>               <int>     <int>             <dbl>\n 1 Chad  Unidad 1 Comercial               4         3             0.429\n 2 Chad  Unidad 1 R&D                     5         1             0.167\n 3 Chad  Unidad 2 Administraci√≥n          3         6             0.667\n 4 Chad  Unidad 2 Calidad                 1         0             0    \n 5 Chad  Unidad 2 Comercial               5         1             0.167\n 6 Chad  Unidad 2 Recursos Humanos        3         0             0    \n 7 Chad  Unidad 3 Administraci√≥n          2         2             0.5  \n 8 Chad  Unidad 3 Calidad                 2         2             0.5  \n 9 Chad  Unidad 3 Comercial               5        20             0.8  \n10 Chad  Unidad 3 HSE                     1         0             0    \n# ‚Ñπ 50 more rows\n```\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}