{
  "hash": "75c06c7a33c24c25bd2a7f86e1323fe2",
  "result": {
    "markdown": "---\ntitle: \"Extraer el máximo valor de una fila\"\nauthor: \"Checho\"\ncategories: [tipitos, tip, análisis, dplyr, data wrangling]\n---\n\n\n# Extraer el máximo valor de una fila\n\nEn este pequeño tutorial (por eso el tag de `tipitos`, o sea un tip chiquito, voy a contar cómo resolví un problema que me encontré en el trabajo.\n\nEstaba trabajando con una tabla en la que tenía varios cursos, con sus fechas de finalización, y para el análisis que estaba haciendo necesitaba extraer la fecha del último curso (el valor más alto).\n\nEl problema es que cuando estaba ejecutando la función `max()` en vez de obtener el valor más alto de la fila, obtenía el valor más alto de la columna. Así que en este post vamos a ver la función `rowwise()` que permite resolver este inconveniente.\n\nEn este ejemplo vamos a reemplazar las fechas por un número, que a los fines prácticos plantea el mismo problema.\n\n## Datos de ejemplo\n\nPrimero carguemos la librería `dplyr` que además de contener la función `rowwise()` nos permite trabajar con el *pipe* `%>%`. Luego crearemos un data frame de ejemplo con datos inventados\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# En caso que no esté instalado 'dplyr' primero ejecutar install.package(\"dplyr\")\nlibrary(dplyr)\n\n# Creación de datos\nejemplo <- data.frame(\"Nombre\" = c(\"Carla\", \"Daniela\", \"Sergio\", \"Yanel\"),\n                    \"Valor A\" = c(12, 8, 300, 17),\n                    \"Valor B\" = c(5, 21, 18, 400),\n                    \"Valor C\" = c(39, 200, 26, 64), \n                    \"Valor D\" = c(100, 43, 86, 12))\n```\n:::\n\n\nAhora veamos cómo quedan los datos\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Ejecutar para ver el contenido del data frame\nejemplo\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Nombre Valor.A Valor.B Valor.C Valor.D\n1   Carla      12       5      39     100\n2 Daniela       8      21     200      43\n3  Sergio     300      18      26      86\n4   Yanel      17     400      64      12\n```\n:::\n:::\n\n\nLo que necesitaba lograr (en un archivo con muchas más columnas que en este ejemplo) es poner en una columna nueva el valor más alto para cada persona. Entonces para `Carla` esperaba que el resultado fuera `100`, para `Daniela` `200` y así sucesivamente.\n\nInstintivamente lo que hice fue dentro de una función `mutate()` (para crear una columna nueva) pasar la función `max()` a un vector con los nombres de las 4 columnas.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nejemplo %>% \n  mutate(\"Valor Máximo\" = max(c(Valor.A, Valor.B, Valor.C, Valor.D)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   Nombre Valor.A Valor.B Valor.C Valor.D Valor Máximo\n1   Carla      12       5      39     100          400\n2 Daniela       8      21     200      43          400\n3  Sergio     300      18      26      86          400\n4   Yanel      17     400      64      12          400\n```\n:::\n:::\n\n\nClaramente no es es el resultado que esperaba, así que mi reacción fue la siguiente:\n\n![](https://media.giphy.com/media/PmRgaD2xj0KH2pPrVF/giphy.gif){width=\"286\"}\n\n## La solución\n\nEl problema del enfoque anterior es que la función `max()` busca entre todos los datos que le pasamos, las 4 columnas con valores numéricos, y nos devuelve el valor máximo de entre todas las celdas. **En esencia R está haciendo lo que le pedimos que haga, no lo que estábamos queriendo que haga**.\n\nPara resolver esto, antes de crear una columna nueva con `mutate()`, usamos la función `rowwise()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nejemplo %>% \n  rowwise() %>%   # Con esta función indicamos que queremos los cálculos sobre las filas\n  mutate(\"Valor Máximo\" = max(c(Valor.A, Valor.B, Valor.C, Valor.D)))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 6\n# Rowwise: \n  Nombre  Valor.A Valor.B Valor.C Valor.D `Valor Máximo`\n  <chr>     <dbl>   <dbl>   <dbl>   <dbl>          <dbl>\n1 Carla        12       5      39     100            100\n2 Daniela       8      21     200      43            200\n3 Sergio      300      18      26      86            300\n4 Yanel        17     400      64      12            400\n```\n:::\n:::\n\n\nLa función `rowwise()` lo que nos permite hacer es cálculos sobre las filas. Dependiendo el caso de uso se puede usar esta alternativa, o *\"pivotear\"* o *transponer* la tabla para que las columnas queden dentro de las filas y luego combinar `group_by()` y `summarise()` para calcular el valor máximo para cada persona.\n\nEste enfoque sería así:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyr)\n\nejemplo %>% \n  # Pivoteamos los datos a un formato 'largo'\n  pivot_longer(cols = c(\"Valor.A\", \"Valor.B\", \"Valor.C\", \"Valor.D\"), \n               names_to = \"Variable\",\n               values_to = \"Valor\") %>% \n  group_by(Nombre) %>% \n  summarise(\"Valor Máximo\" = max(Valor))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n# A tibble: 4 × 2\n  Nombre  `Valor Máximo`\n  <chr>            <dbl>\n1 Carla              100\n2 Daniela            200\n3 Sergio             300\n4 Yanel              400\n```\n:::\n:::\n\n\nClaramente este es otro enfoque, y depende de la necesidad es una opción válida. Pero en este caso particular necesitaba mantener una fila para cada persona porque después iba a exportar esta tabla a un archivo que luego es cargado en un tablero en Power BI.\n\nAsí que, una vez logrado mi objetivo, me dispongo a celebrar como corresponde.\n\n![](https://media.giphy.com/media/lhwgeqN0pLPBMlFNnn/giphy.gif)\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}